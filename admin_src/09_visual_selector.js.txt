// --- Visual Selector ---
let currentVisualMode = 'item';
let currentPreviewMode = 'item';
// JSON/RSS sniffing state
let isSniffing = false;

// é¢„è§ˆæ¨¡å¼åˆ‡æ¢å‡½æ•°
window.setPreviewMode = function (mode) {
    currentPreviewMode = mode;
    const type = document.getElementById('type').value;

    // Update UI buttons
    document.querySelectorAll('#visualPreview .tool-btn').forEach(btn => {
        btn.classList.remove('bg-blue-100', 'text-blue-700', 'border-blue-300');
        btn.classList.add('bg-white', 'text-gray-700');
    });

    const btn = document.getElementById('preview-btn-' + mode);
    if (btn) {
        btn.classList.remove('bg-white', 'text-gray-700');
        btn.classList.add('bg-blue-100', 'text-blue-700', 'border-blue-300');
    }

    // å‘é€æ¨¡å¼åˆ° iframeï¼ˆä»…åœ¨ HTML æ¨¡å¼ä¸‹ï¼‰
    if (type !== 'json') {
        const frame = document.getElementById('previewFrame');
        if (frame.contentWindow && frame.src) {
            const itemSelector = document.getElementById('itemSelector').value;
            frame.contentWindow.postMessage({
                type: 'setMode',
                mode: mode,
                selectorType: type,
                itemSelector: itemSelector
            }, '*');
        }
    }
};

// Collapsible Panel Logic (Moved from Navigation to here or kept global? It was in 02_nav.js, but duplicated in source. I will rely on 02_nav.js for it if exported, or just ensure it exists.)
// It is in 02_nav.js, so I won't redefine it here to avoid conflicts, or I check if it exists.
// Actually 02_nav.js defines it on window. So it's fine.

function xmlToJson(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, "text/xml");

    function elementToObj(element) {
        const obj = {};
        // Attributes
        if (element.attributes && element.attributes.length > 0) {
            for (let i = 0; i < element.attributes.length; i++) {
                const attr = element.attributes[i];
                obj['@' + attr.name] = attr.value;
            }
        }

        // Children
        if (element.children.length === 0) {
            const text = element.textContent.trim();
            if (Object.keys(obj).length === 0) return text;
            if (text) obj['#text'] = text;
            return obj;
        }

        for (let i = 0; i < element.children.length; i++) {
            const child = element.children[i];
            const childName = child.tagName;
            const childObj = elementToObj(child);

            if (obj[childName]) {
                if (!Array.isArray(obj[childName])) {
                    obj[childName] = [obj[childName]];
                }
                obj[childName].push(childObj);
            } else {
                obj[childName] = childObj;
            }
        }
        return obj;
    }

    const root = doc.documentElement;
    const result = {};
    if (root) {
        result[root.tagName] = elementToObj(root);
    }
    return result;
}


// åŠ è½½é¢„è§ˆé¡µé¢
window.loadPreview = async function () {
    const rawUrl = document.getElementById('url').value;
    const url = rawUrl ? normalizeUrl(rawUrl) : rawUrl;
    const type = document.getElementById('type').value;

    // ç¡®ä¿åˆ‡æ¢å›é¢„è§ˆæ¨¡å¼
    document.getElementById('previewTitle').textContent = 'å¯è§†åŒ–é¢„è§ˆ';
    document.getElementById('visualPreview').classList.remove('hidden');
    document.getElementById('testResult').classList.add('hidden');

    if (!url) {
        document.getElementById('previewFrame').src = '';
        document.getElementById('jsonPreview').innerHTML = '';
        return;
    }

    if (type === 'json' || type === 'rss') {
        // JSON/RSS Preview
        document.getElementById('previewFrame').classList.add('hidden');
        document.getElementById('previewToolbar').classList.remove('hidden'); // Show toolbar
        document.getElementById('jsonPreview').classList.remove('hidden');
        document.getElementById('jsonPreview').innerHTML = '<div class="text-center text-gray-400 py-10">åŠ è½½ä¸­...</div>';

        // Update toolbar labels
        document.getElementById('preview-btn-item').textContent = 'ğŸ“¦ åˆ—è¡¨æ•°ç»„';
        document.getElementById('preview-btn-title').textContent = 'ğŸ“ æ ‡é¢˜å­—æ®µ';
        document.getElementById('preview-btn-link').textContent = 'ğŸ”— é“¾æ¥å­—æ®µ';
        document.getElementById('preview-btn-desc').textContent = 'ğŸ“„ æè¿°å­—æ®µ';
        document.getElementById('preview-btn-date').textContent = 'ğŸ“… æ—¥æœŸå­—æ®µ';

        try {
            // Use proxy to get raw content
            // Prefer saved route encoding when editing an existing route
            const routeKey = document.getElementById('routeKey').value;
            let enc = document.getElementById('encoding').value || 'auto';
            if (routeKey && cachedRoutes[routeKey] && cachedRoutes[routeKey].encoding) enc = cachedRoutes[routeKey].encoding;
            const encVal = encodeURIComponent(enc);
            const response = await authFetch(PROXY_JSON_API + '?url=' + encodeURIComponent(url) + '&encoding=' + encVal);
            let data;
            if (type === 'rss') {
                const text = await response.text();
                data = xmlToJson(text);
            } else {
                data = await response.json();
            }
            renderJsonTree(data, '', 0, document.getElementById('jsonPreview'));
        } catch (e) {
            document.getElementById('jsonPreview').innerHTML = '<div class="text-center text-red-400 py-10">åŠ è½½å¤±è´¥: ' + e.message + '</div>';
        }
        return;
    }

    // HTML Preview
    document.getElementById('previewFrame').classList.remove('hidden');
    document.getElementById('previewToolbar').classList.remove('hidden');
    document.getElementById('jsonPreview').classList.add('hidden');

    // Reset toolbar labels for HTML
    document.getElementById('preview-btn-item').textContent = 'æ¡ç›®';
    document.getElementById('preview-btn-title').textContent = 'æ ‡é¢˜';
    document.getElementById('preview-btn-link').textContent = 'é“¾æ¥';
    document.getElementById('preview-btn-desc').textContent = 'æè¿°';
    document.getElementById('preview-btn-date').textContent = 'æ—¥æœŸ';

    const previewFrame = document.getElementById('previewFrame');
    const jsonPreview = document.getElementById('jsonPreview');
    // Use fetch to detect proxy errors (Cloudflare 1002 etc.) and show friendly message
    (async () => {
        try {
            // Prefer saved route encoding when editing an existing route
            const routeKey = document.getElementById('routeKey').value;
            let enc = document.getElementById('encoding').value || 'auto';
            if (routeKey && cachedRoutes[routeKey] && cachedRoutes[routeKey].encoding) enc = cachedRoutes[routeKey].encoding;
            const encVal = encodeURIComponent(enc);

            const usePuppeteer = document.getElementById('usePuppeteer').checked;
            let apiUrl = PROXY_API + '?url=' + encodeURIComponent(url) + '&encoding=' + encVal;
            if (usePuppeteer) {
                apiUrl += '&use_puppeteer=true';
                const w = document.getElementById('puppeteerWaitSelector').value;
                if (w) apiUrl += '&wait=' + encodeURIComponent(w);
            }

            const res = await authFetch(apiUrl);
            const ct = res.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
                const data = await res.json();
                // If proxy returned structured error, show friendly message instead of raw error page
                if (data && data.error) {
                    previewFrame.classList.add('hidden');
                    jsonPreview.classList.remove('hidden');
                    jsonPreview.innerHTML = `<div class="text-center p-6 text-sm text-red-600">é¢„è§ˆå¤±è´¥: ${escapeHtml(data.message || data.error)}</div>`;
                    return;
                }
            }

            // Otherwise treat as HTML/text and render inside iframe using srcdoc
            const text = await res.text();
            previewFrame.classList.remove('hidden');
            jsonPreview.classList.add('hidden');
            try {
                previewFrame.srcdoc = text;
                // ç«‹å³å°è¯•æ³¨å…¥é€‰æ‹©å™¨è„šæœ¬ï¼ˆsrcdoc å¯ç›´æ¥è®¿é—®ï¼‰
                // injectSelectorScriptToFrame(previewFrame); 
                // NOTE: Script is now injected by proxy.js server-side. Client-side injection disabled to avoid conflicts.
            } catch (e) {
                // Fallback: create blob URL
                const blob = new Blob([text], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                previewFrame.src = blobUrl;
            }

            // åœ¨ iframe åŠ è½½å®Œæˆæ—¶å†æ¬¡å°è¯•æ³¨å…¥å¹¶è®¾ç½®æ¨¡å¼
            previewFrame.onload = function () {
                // try { injectSelectorScriptToFrame(previewFrame); } catch (e) {}
                try { setPreviewMode(currentPreviewMode); } catch (e) { }
            };
            // å…¼å®¹æƒ…å†µï¼Œå»¶è¿Ÿè®¾ç½®ä¸€æ¬¡æ¨¡å¼
            setTimeout(() => setPreviewMode(currentPreviewMode), 500);
        } catch (e) {
            previewFrame.classList.add('hidden');
            jsonPreview.classList.remove('hidden');
            jsonPreview.innerHTML = `<div class="text-center p-6 text-sm text-red-600">è¯·æ±‚é¢„è§ˆå¤±è´¥: ${escapeHtml(e.message || String(e))}</div>`;
        }
    })();
};

window.addEventListener('message', (e) => {
    if (e.data && e.data.type === 'selected') {
        const { mode, selector } = e.data;

        if (mode === 'item') {
            document.getElementById('itemSelector').value = selector;
        } else if (mode === 'title') {
            document.getElementById('titleSelector').value = selector;
        } else if (mode === 'link') {
            // æ™ºèƒ½å¤„ç†é“¾æ¥ï¼šå¦‚æœé€‰æ‹©å™¨å·²ç»æ˜¯ a æ ‡ç­¾ï¼Œåˆ™ä½¿ç”¨ @href è·å–é“¾æ¥
            let linkSelector = selector;
            if (selector.toLowerCase().includes('a') && !selector.includes('@href')) {
                // å¦‚æœé€‰æ‹©å™¨åŒ…å« a æ ‡ç­¾ï¼Œå°è¯•æ·»åŠ  @href æ¥è·å–é“¾æ¥å±æ€§
                linkSelector = selector + '/@href';
            }
            document.getElementById('linkSelector').value = linkSelector;
        } else if (mode === 'desc') {
            document.getElementById('descSelector').value = selector;
        } else if (mode === 'date') {
            document.getElementById('dateSelector').value = selector;
        }

        try { showSelectorCandidates(mode, selector); } catch (err) { console.warn(err); }

        // ADGUARD STYLE: Update Refinement Toolbar
        const toolbar = document.getElementById('selectionRefineToolbar');
        if (toolbar) {
            toolbar.classList.remove('hidden');
            const depth = e.data.depth || 0;
            document.getElementById('depthSlider').value = depth;
            document.getElementById('depthLabel').textContent = 'å±‚çº§: ' + depth;
        }
    } else if (e.data && e.data.type === 'selectorCounts') {
        try { renderCandidateCounts(e.data.counts || {}); } catch (err) { console.warn(err); }
    } else if (e.data && e.data.type === 'ajax-sniff') {
        if (!isSniffing) return;
        const { url, method, type } = e.data.payload;
        // Simple filter
        if (!url.startsWith('http')) return;

        const panel = document.getElementById('snifferResults');
        // Remove placeholder
        if (panel.textContent.includes('ç›‘å¬ä¸­')) panel.innerHTML = '';

        // Check dupes
        const exists = Array.from(panel.children).some(el => el.dataset.url === url);
        if (exists) return;

        const div = document.createElement('div');
        div.className = 'flex items-center gap-2 p-1.5 bg-white border border-gray-200 rounded hover:bg-blue-50 cursor-pointer break-all transition-colors';
        div.dataset.url = url;
        div.onclick = () => useSniffedUrl(url);
        div.innerHTML = `
            <span class="text-[10px] font-mono px-1 rounded ${method === 'GET' ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'}">${method}</span>
            <span class="text-[10px] font-mono px-1 rounded bg-gray-100 text-gray-600">${type}</span>
            <span class="flex-1 truncate text-xs text-gray-700" title="${url}">${url}</span>
            <button class="text-blue-600 hover:text-blue-800 text-[10px] whitespace-nowrap px-2 py-0.5 border border-blue-200 bg-white rounded hover:bg-blue-50">ä½¿ç”¨</button>
        `;
        panel.insertBefore(div, panel.firstChild);
    }
});

// ç”Ÿæˆå€™é€‰é€‰æ‹©å™¨ï¼ˆç®€å•ç­–ç•¥ï¼‰
function generateCandidatesFrom(selector) {
    if (!selector) return [];
    const candidates = [];
    candidates.push(selector);
    candidates.push(selector.replace(/:nth-child\(\d+\)/g, ''));
    const m = selector.match(/([a-z0-9_-]+)\.[a-z0-9_-]+/i);
    if (m) candidates.push(m[0]);
    const parts = selector.split('>').map(s => s.trim()).filter(Boolean);
    if (parts.length > 1) {
        const last = parts[parts.length - 1];
        const parent = parts[parts.length - 2];
        candidates.push(parent + ' > ' + last.replace(/:nth-child\(\d+\)/g, ''));
    }
    const clsMatch = selector.match(/\.[a-z0-9_-]+/ig);
    if (clsMatch && clsMatch.length > 0) {
        candidates.push(clsMatch.slice(0, 2).join(''));
    }
    return Array.from(new Set(candidates)).slice(0, 10);
}

// åœ¨ preview å·¥å…·æ æ˜¾ç¤ºå€™é€‰é€‰æ‹©å™¨åˆ—è¡¨
function showSelectorCandidates(mode, selector) {
    const toolbar = document.getElementById('previewToolbar');
    if (!toolbar) return;
    let panel = document.getElementById('selectorCandidates');
    if (!panel) {
        panel = document.createElement('div');
        panel.id = 'selectorCandidates';
        panel.style.padding = '6px';
        panel.style.borderTop = '1px solid #eee';
        panel.style.display = 'flex';
        panel.style.flexDirection = 'column';
        panel.style.gap = '6px';
        toolbar.appendChild(panel);
    }
    panel.innerHTML = '<div class="text-xs text-gray-600">å€™é€‰é€‰æ‹©å™¨ï¼ˆç‚¹å‡»â€œé¢„è§ˆâ€æŸ¥çœ‹æ•ˆæœï¼Œæˆ–â€œä½¿ç”¨â€å¡«å…¥è¡¨å•ï¼‰</div>';
    const candidates = generateCandidatesFrom(selector);
    candidates.forEach(c => {
        const row = document.createElement('div');
        row.className = 'flex items-center gap-2';
        row.innerHTML = `
            <div class="text-xs text-gray-800 truncate" style="flex:1" title="${escapeHtml(c)}">${escapeHtml(c)}</div>
            <div class="flex gap-1">
                <button class="btn-cand-preview text-xs px-2 py-1">é¢„è§ˆ</button>
                <button class="btn-cand-use text-xs px-2 py-1">ä½¿ç”¨</button>
            </div>
        `;
        const previewBtn = row.querySelector('.btn-cand-preview');
        const useBtn = row.querySelector('.btn-cand-use');
        previewBtn.onclick = () => applyPreviewSelector(c);
        useBtn.onclick = () => {
            if (mode === 'item') document.getElementById('itemSelector').value = c;
            else if (mode === 'title') document.getElementById('titleSelector').value = c;
            else if (mode === 'link') document.getElementById('linkSelector').value = c;
            else if (mode === 'desc') document.getElementById('descSelector').value = c;
            else if (mode === 'date') document.getElementById('dateSelector').value = c;
        };
        panel.appendChild(row);
    });

    try {
        const frame = document.getElementById('previewFrame');
        if (frame && frame.contentWindow) {
            frame.contentWindow.postMessage({ type: 'countSelectors', candidates: candidates }, '*');
        }
    } catch (e) { console.warn(e); }
}

// æ¸²æŸ“æ¥è‡ª iframe çš„è®¡æ•°ç»“æœ
function renderCandidateCounts(counts) {
    const panel = document.getElementById('selectorCandidates');
    if (!panel) return;
    const rows = panel.querySelectorAll('div.flex.items-center');
    rows.forEach(row => {
        const textDiv = row.querySelector('div');
        const selector = textDiv && textDiv.title;
        if (!selector) return;
        const count = counts[selector] != null ? counts[selector] : counts[decodeURIComponent(selector)];
        let badge = row.querySelector('.cand-count');
        if (!badge) {
            badge = document.createElement('div');
            badge.className = 'cand-count text-xs text-gray-500';
            badge.style.minWidth = '48px';
            badge.style.textAlign = 'right';
            row.insertBefore(badge, row.querySelector('.flex'));
        }
        badge.textContent = (typeof count === 'number' && count >= 0) ? (count + ' ä¸ª') : 'æœªçŸ¥';
    });
}

function applyPreviewSelector(selector) {
    const frame = document.getElementById('previewFrame');
    if (!frame || !frame.contentWindow) return;
    frame.contentWindow.postMessage({ type: 'previewClear' }, '*');
    frame.contentWindow.postMessage({ type: 'previewApply', selector: selector }, '*');
}

// --- Selection Refinement (AdGuard Style) ---
window.adjustSelectionDepth = function (delta) {
    const slider = document.getElementById('depthSlider');
    let val = parseInt(slider.value) + delta;
    if (val < parseInt(slider.min)) val = parseInt(slider.min);
    if (val > parseInt(slider.max)) val = parseInt(slider.max);
    slider.value = val;
    onDepthChange(val);
};

window.onDepthChange = function (val) {
    document.getElementById('depthLabel').textContent = 'å±‚çº§: ' + val;
    const frame = document.getElementById('previewFrame');
    if (frame && frame.contentWindow) {
        frame.contentWindow.postMessage({ type: 'setDepth', depth: parseInt(val) }, '*');
    }
};

// ===== JSON é€‰æ‹©å™¨åŠŸèƒ½ =====

function renderJsonTree(data, path = '', level = 0, container = null) {
    const viewer = container || document.getElementById('jsonPreview');
    if (level === 0) viewer.innerHTML = '';

    const indent = '  '.repeat(level);
    const isArray = Array.isArray(data);
    const isObject = typeof data === 'object' && data !== null && !isArray;

    if (isArray) {
        const arrayPath = path || ''; // Root array path is empty string or just use what is passed

        const el = document.createElement('div');
        el.className = 'cursor-pointer hover:bg-gray-800 px-1';
        el.title = 'ç‚¹å‡»é€‰æ‹©æ­¤æ•°ç»„: ' + (arrayPath || 'root');
        el.innerHTML = indent + '<span class="text-gray-500">[</span> <span class="text-yellow-400 text-xs">(æ•°ç»„ï¼Œå…±' + data.length + 'é¡¹)</span>';

        // æ•°ç»„å¼€å§‹æ‹¬å·å¯ç‚¹å‡»
        el.onclick = function (e) {
            e.stopPropagation();
            if (currentPreviewMode === 'item') {
                selectJsonPath(arrayPath);
            }
        };

        viewer.appendChild(el);

        // åªæ˜¾ç¤ºå‰3ä¸ªå…ƒç´ 
        const itemsToShow = Math.min(3, data.length);
        for (let i = 0; i < itemsToShow; i++) {
            renderJsonTree(data[i], path + '[' + i + ']', level + 1, viewer);
        }

        if (data.length > 3) {
            const moreEl = document.createElement('div');
            moreEl.className = 'text-gray-500';
            moreEl.innerHTML = indent + '  <span class="italic">... è¿˜æœ‰ ' + (data.length - 3) + ' é¡¹</span>';
            viewer.appendChild(moreEl);
        }

        const closeEl = document.createElement('div');
        closeEl.className = 'cursor-pointer hover:bg-gray-800 px-1';
        closeEl.title = 'ç‚¹å‡»é€‰æ‹©æ­¤æ•°ç»„: ' + (arrayPath || 'root');
        closeEl.innerHTML = indent + '<span class="text-gray-500">]</span>';

        // é—­åˆæ‹¬å·ä¹Ÿå¯ç‚¹å‡»
        closeEl.onclick = function (e) {
            e.stopPropagation();
            if (currentPreviewMode === 'item') {
                selectJsonPath(arrayPath);
            }
        };

        viewer.appendChild(closeEl);
    } else if (isObject) {
        const el = document.createElement('div');
        el.innerHTML = indent + '<span class="text-gray-500">{</span>';
        viewer.appendChild(el);

        for (const key in data) {
            const value = data[key];
            const currentPath = path ? path + '.' + key : key;
            const valueType = Array.isArray(value) ? 'array' : typeof value;

            if (valueType === 'object' || valueType === 'array') {
                const keyEl = document.createElement('div');

                // å¦‚æœæ˜¯æ•°ç»„ï¼Œè®©keyä¹Ÿå¯ä»¥ç‚¹å‡»
                if (valueType === 'array') {
                    keyEl.className = 'cursor-pointer hover:bg-gray-800 px-1';
                    keyEl.title = 'ç‚¹å‡»é€‰æ‹©æ­¤æ•°ç»„: ' + currentPath;
                    keyEl.innerHTML = indent + '  <span class="text-blue-400">"' + key + '"</span>: <span class="text-yellow-400 text-xs">[æ•°ç»„]</span>';
                    keyEl.onclick = function (e) {
                        e.stopPropagation();
                        if (currentPreviewMode === 'item') {
                            selectJsonPath(currentPath);
                        }
                    };
                } else {
                    keyEl.innerHTML = indent + '  <span class="text-blue-400">"' + key + '"</span>: ';
                }

                viewer.appendChild(keyEl);
                renderJsonTree(value, currentPath, level + 1, viewer);
            } else {
                const lineEl = document.createElement('div');
                lineEl.className = 'cursor-pointer hover:bg-gray-800 px-1';
                lineEl.title = 'ç‚¹å‡»é€‰æ‹©: ' + currentPath;

                let displayValue = JSON.stringify(value);
                if (displayValue.length > 50) displayValue = displayValue.substring(0, 50) + '...';

                let color = 'text-green-400';
                if (valueType === 'number') color = 'text-yellow-400';
                else if (valueType === 'boolean') color = 'text-purple-400';
                else if (value === null) color = 'text-gray-500';

                lineEl.innerHTML = indent + '  <span class="text-blue-400">"' + key + '"</span>: <span class="' + color + '">' + displayValue + '</span>,';

                lineEl.onclick = function (e) {
                    e.stopPropagation();
                    if (currentPreviewMode !== 'item') {
                        selectJsonPath(key);
                    }
                };

                viewer.appendChild(lineEl);
            }
        }

        const closeEl = document.createElement('div');
        closeEl.innerHTML = indent + '<span class="text-gray-500">}</span>';
        viewer.appendChild(closeEl);
    } else {
        // åŸºæœ¬ç±»å‹ç›´æ¥æ˜¾ç¤º
    }
}

function selectJsonPath(path) {
    if (!path) return;

    // å¦‚æœæ˜¯ item æ¨¡å¼ï¼Œè·¯å¾„åº”è¯¥æ˜¯ data.items è¿™ç§
    if (currentPreviewMode === 'item') {
        // JSONæ¨¡å¼ä¸‹ï¼Œitemé€‰æ‹©å™¨å°±æ˜¯æ•°ç»„çš„è·¯å¾„
        // å¦‚æœæ˜¯æ ¹æ•°ç»„ï¼Œå¯èƒ½æ˜¯ç©ºå­—ç¬¦ä¸²æˆ– "items"
        document.getElementById('itemSelector').value = path.startsWith('root.') ? path.substring(5) : path;
    } else {
        // å­—æ®µæ¨¡å¼ï¼šè·¯å¾„é€šå¸¸ç›¸å¯¹äº itemï¼Œæ¯”å¦‚ "title"
        // æˆ‘ä»¬å°è¯•è®¡ç®—ç›¸å¯¹è·¯å¾„
        const itemVal = document.getElementById('itemSelector').value;
        if (itemVal && path.startsWith(itemVal)) {
            let rel = path.substring(itemVal.length);
            if (rel.startsWith('.')) rel = rel.substring(1);
            else if (rel.startsWith('[')) {
                // items[0].title -> title
                // Handle array indices
                const m = rel.match(/^\[\d+\]\.(.*)$/);
                if (m) rel = m[1];
            }
            // å¦‚æœ path æ˜¯ items[0].titleï¼ŒitemSelectoræ˜¯ itemsï¼Œrelative æ˜¯ [0].title
            // ç®€å•å¤„ç†ï¼šåªå–æœ€åä¸€ä¸ªç‚¹åé¢çš„
            const parts = path.split('.');
            if (parts.length > 0) rel = parts[parts.length - 1];

            if (currentPreviewMode === 'title') document.getElementById('titleSelector').value = rel;
            else if (currentPreviewMode === 'link') document.getElementById('linkSelector').value = rel;
            else if (currentPreviewMode === 'desc') document.getElementById('descSelector').value = rel;
            else if (currentPreviewMode === 'date') document.getElementById('dateSelector').value = rel;
        } else {
            // Fallback: just use full path specific leaf
            if (currentPreviewMode === 'title') document.getElementById('titleSelector').value = path;
            else if (currentPreviewMode === 'link') document.getElementById('linkSelector').value = path;
            else if (currentPreviewMode === 'desc') document.getElementById('descSelector').value = path;
            else if (currentPreviewMode === 'date') document.getElementById('dateSelector').value = path;
        }
    }

    // Highlight UI?
    alert('å·²é€‰æ‹© ' + currentPreviewMode + ': ' + path);
}

// Sniffer Logic
window.toggleSniffer = function () {
    isSniffing = !isSniffing;
    const btn = document.getElementById('snifferBtn');
    const panel = document.getElementById('snifferPanel');
    const dot = document.getElementById('snifferDot');

    if (isSniffing) {
        btn.classList.add('bg-blue-100', 'text-blue-700');
        panel.classList.remove('hidden');
        dot.classList.remove('hidden');
        document.getElementById('snifferResults').innerHTML = '<div class="text-xs text-gray-400 p-2 text-center">ç›‘å¬ä¸­... è¯·åœ¨é¡µé¢ä¸­è¿›è¡Œæ“ä½œè§¦å‘è¯·æ±‚</div>';

        // Notify iframe
        const frame = document.getElementById('previewFrame');
        if (frame && frame.contentWindow) {
            frame.contentWindow.postMessage({ type: 'startSniff' }, '*');
        }
    } else {
        btn.classList.remove('bg-blue-100', 'text-blue-700');
        panel.classList.add('hidden');
        dot.classList.add('hidden');

        const frame = document.getElementById('previewFrame');
        if (frame && frame.contentWindow) {
            frame.contentWindow.postMessage({ type: 'stopSniff' }, '*');
        }
    }
};

window.useSniffedUrl = function (url) {
    document.getElementById('url').value = url;
    document.getElementById('type').value = 'json'; // Assume JSON API
    updatePlaceholder();
    toggleSniffer(); // Close sniffer
    loadPreview();
};
